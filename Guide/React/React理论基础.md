React 是什么？    
React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，这些代码片段被称作“组件”。    
当数据发生改变时，React 会高效地更新并重新渲染我们的组件。    
一个组件接收一些参数，我们把这些参数叫做 props（“props” 是 “properties” 简写），然后通过 render 方法返回需要展示在屏幕上的视图的层次结构。    
更具体地来说，render 返回了一个 React 元素。    
每一个 React 元素事实上都是一个 JavaScript 对象，可以保存在变量中或者作为参数传递。每个组件都是封装好的，并且可以单独运行，这样你就可以通过组合简单的组件来构建复杂的 UI 界面。    
在 React 应用中，数据通过 props 的传递，从父组件流向子组件。    
在 JavaScript class 中，每次你定义其子类的构造函数时，都需要调用 super 方法。因此，在所有含有构造函数的的 React 组件中，构造函数必须以 super(props) 开头。    
“状态提升”    
当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的 state 数据提升至其共同的父组件当中保存。之后父组件可以通过 props 将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够更方便地同步共享了。
像这种将组件的 state 提升到父组件的情形在重构 React 组件时经常会遇到。    
state 对于每个组件来说是私有的。    
return的内容用()包裹，防止JavaScript 解析的时在 return 的后面自动插入一个分号从而破坏代码结构。    
应该依赖自顶向下的数据流，而不是尝试同步不同组件之间的状态。    
确定UI状态的最小(但完整)表示：如果某些东西可以从props或state中派生，那么它可能不应该处于状态中。    


“受控组件”不持有state(也就不需要构造方法)，状态完全受控于父组件    

为什么不可变性在 React 中非常重要    
一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据。两者结果是一样的，但后者有以下几点好处：    

不可变性使得复杂的特性更容易实现。不直接在数据上修改可以让我们保存每次修改前的数据副本，从而追溯并复用历史记录，实现撤销和恢复。    

不可变性使得跟踪数据变化更容易。如果发现对象变成了一个新对象，那么我们就知道对象发生了改变。而不需要将整个对象树遍历一次。    

不可变性最主要的优势在于它可以帮助我们在 React 中创建 pure components。我们可以由此确定组件重新渲染的时机。    

“函数组件”    
如果你想写的组件只包含一个 render 方法，并且不包含 state，那么使用函数组件就会更简单。我们不需要定义一个继承于 React.Component 的类，我们可以定义一个函数，这个函数接收 props 作为参数，然后返回需要渲染的元素。函数组件写起来并不像 class 组件那么繁琐，很多组件都可以使用函数组件来写。
    
key 是 React 中一个特殊的保留属性（还有一个是 ref，拥有更高级的特性）。当 React 元素被创建出来的时候，React 会提取出 key 属性，然后把 key 直接存储在返回的元素上。虽然 key 看起来好像是 props 中的一个，但是你不能通过 this.props.key 来获取 key。React 会通过 key 来自动判断哪些组件需要更新。组件是不能访问到它的 key 的。
    
我们强烈推荐，每次只要你构建动态列表的时候，都要指定一个合适的 key。如果你没有找到一个合适的 key，那么你就需要考虑重新整理你的数据结构了，这样才能有合适的 key。
    
如果你没有指定任何 key，React 会发出警告，并且会把数组的索引当作默认的 key。但是如果想要对列表进行重新排序、新增、删除操作时，把数组索引作为 key 是有问题的。显式地使用 key={i} 来指定 key 确实会消除警告，但是仍然和数组索引存在同样的问题，所以大多数情况下最好不要这么做。
    
组件的 key 值并不需要在全局都保证唯一，只需要在当前的同一级元素之前保证唯一即可。
    



Chrome-React调试插件https://www.cnblogs.com/shenwh/p/12067029.html    
Sublime-React格式化     
https://blog.csdn.net/HuangLin_Developer/article/details/89394949    



JSX    
函数组件转化成类组件三步    
State的三点    
生命周期方法    
事件绑定    
列表元素的key   有利于在列表头部插入新节点时提高效率。何时需要key？一个好的经验法则是map()调用中的元素需要key。key要在兄弟间唯一，不需要全局唯一。key不会传递即无法通过props.key访问到，需要使用key值时要单独传递新属性。键应该是稳定的、可预测的和惟一的。不建议使用索引，在发生顺序变化时可能引发意料外的渲染，不建议使用随机数，这可能导致性能下降和在子组件中丢失状态。
    
用组合模型而非继承来重用代码    
组件可以接受任意的props，包括原始值、React元素或函数。    
如果您希望在组件之间重用非ui功能，我们建议将其提取到单独的JavaScript模块中。组件可以导入它并使用该函数、对象或类，而不需要扩展它。    
在较简单的示例中，通常更容易自顶向下，而在较大的项目中，更容易自底向上并在构建时编写测试。    
组件只有render()方法，因为这是应用程序的静态版本。层次结构顶部的组件将以你的数据模型为支撑。如果对基础数据模型进行更改并再次调用ReactDOM.render()，则将更新UI。您可以看到UI是如何更新的，以及在哪里进行更改。React的单向数据流(也称为单向绑定)使一切都保持模块化和快速。
要使UI具有交互性，您需要能够触发对底层数据模型的更改。React用state实现这一点。    

步骤1:将UI分解为组件层次结构    

步骤2:在React中构建静态版本    
道具是将数据从父元素传递给子元素的一种方式。如果您熟悉状态的概念，请不要使用状态来构建此静态版本。状态仅为交互性保留，即随时间变化的数据。因为这是应用程序的静态版本，所以不需要它。    

步骤3:确定UI状态的最小(但完整)表示    
它是通过props从父级传递进来的吗?如果是这样，它可能不是state。    
它会随时间保持不变吗?如果是这样，它可能不是state。    
你能根据组件中的其他状态或道具来计算吗?如果是这样，它就不是state。    

步骤4:确定React哪个组件拥有state    
识别每个基于那个状态呈现东西的组件。    
找到一个公共所有者组件(在层次结构中需要该状态的所有组件之上的一个组件)。    
公共所有者或其他更高层次的组成部分应该拥有state。    
如果找不到可以拥有状态的组件，可以创建一个新的组件来保存状态，并将其添加到公共所有者组件之上的某个层次结构中。    

步骤5:添加反向数据流    

懒加载lazy    
上下文context    
当某些数据需要由不同嵌套级别的许多组件访问时，主要使用上下文。谨慎地应用它，因为它使组件重用更加困难。上下文允许您将此类数据及其更改“广播”给下面的所有组件。使用上下文可能比其他方法更简单的常见示例包括管理当前语言环境、主题或数据缓存。
如果您只是想避免在许多级别传递一些props，那么组件组合通常是比上下文更简单的解决方案。    
将子组件作为props传递，也可用此模式将子节点与其直接父节点解耦    

错误边界的工作原理类似于JavaScript catch{}块，但它用于组件。只有类组件可以是错误边界。    
错误边界只捕获树中它们下面的组件中的错误。错误边界不能捕获自身内部的错误。如果错误边界无法呈现错误消息，则错误将传播到它上面最近的错误边界。这也类似于JavaScript中的catch{}块的工作方式。    
错误边界的粒度由您决定。您可以包装顶级路由组件以向用户显示“出错了”消息，就像服务器端框架经常处理崩溃一样。您还可以将单个小部件包装在一个错误边界中，以保护它们不会崩溃应用程序的其余部分。    
错误边界不捕捉事件处理程序内部的错误。React不需要从事件处理程序中的错误中恢复错误边界。与呈现方法和生命周期方法不同，事件处理程序不会在呈现期间发生。所以如果他们抛出异常了，React仍然知道在屏幕上显示什么。如果你需要捕获事件处理程序内部的错误，使用常规的JavaScript try / catch语句:
try / catch很棒，但它只适用于命令式代码: 然而，React组件是声明式的，并指定应该呈现的内容:    


生命周期方法    
shouldComponentUpdate 在重新呈现过程开始之前被触发。    
即使React只更新更改的DOM节点，重新呈现仍然需要一些时间。在许多情况下，这不是问题，但是如果减速很明显，您可以通过覆盖生命周期函数shouldComponentUpdate来加速这一切，该函数在重新呈现过程开始之前被触发。这个函数的默认实现返回true，离开React来执行更新
如果您知道在某些情况下您的组件不需要更新，那么您可以从shouldComponentUpdate返回false，从而跳过整个呈现过程，包括在这个组件和下面的组件上调用render()。    
在大多数情况下，不需要手工编写shouldComponentUpdate()，您可以从React.PureComponent继承。这相当于通过对当前和以前的道具和状态进行浅层比较来实现shouldComponentUpdate()。    

Forwarding Refs    
一种通过组件自动将Ref传递给其子组件的技术。对于应用程序中的大多数组件来说，这通常是不必要的。但是，它对某些类型的组件很有用，特别是在可重用组件库中。    
Refs提供了一种访问DOM节点或对render方法中创建的元素做出反应的方法。    
在典型的React数据流中，道具是父组件与子组件交互的唯一方式。要修改一个孩子，你需要用新的道具重新渲染它。但是，在一些情况下，您需要在典型数据流之外强制修改子流。要修改的子元素可以是React组件的实例，也可以是DOM元素。对于这两种情况，React提供了一个逃生口。
        
这里有一些很好的参考用例:    
	管理焦点、文本选择或媒体播放。    
	触发命令动画。    
	与第三方DOM库集成。    


Higher-Order Components  --- 一种组合模式 提取出可重用行为减少代码量 一个方法接收组件参数返回新的带有可重用行为的组件 注意静态方法要复制 refs无法重用 如果向HOC添加ref, ref将引用最外层的容器组件，而不是被包装的组件。幸运的是，我们可以使用React.forwardRef API显式地将refs转发到内部组件。
Render Props  ---  一个提供方法的prop 提高渲染效率 行为具有相关性 可以使用带有Render Prop的常规组件来实现大多数的HOC。 render可以换个名字    
<Mouse render={mouse => (    
  <p>The mouse position is {mouse.x}, {mouse.y}</p>    
)}/>    

this.props.render(this.state) 并不是在组件中修改了props，而是将参数传给props.render       

注意在React.PureComponent中使用Render Props要小心    
使用Render Prop会抵消使用React.PureComponent带来的优势如果在render()中创建方法。这是因为对于新的prop，浅prop比较总是返回false，并且在这种情况下，每次渲染都会为Render Prop生成一个新的值。  这时可以将render prop定义为一个实例方法 提出到render()之外
    
React 16.8 新增hook让您不用编写类就可以使用state和其他React特性。    
为什么会出现钩子hook？    
1. 很难在组件之间重用有状态逻辑：React没有提供将可重用行为添加到组件的方法    
可以通过render props 和HOC尝试解决这个问题，但这要求重构代码。你可能会发现组件的“包装地狱”，由提供者providers、使用者,consumers、高阶组件HOC、渲染道具render props和其他抽象层包围。所以React需要一个更好的原语来共享有状态逻辑。通过使用钩子，可以从组件中提取有状态逻辑，以便能够独立地测试和重用它。    
2. 复杂的组件变得难以理解：    
3. 类混淆了人和机器：除了使代码重用和代码组织更加困难之外，我们还发现类是学习React的一大障碍。    
您必须了解this在JavaScript中是如何工作的，这与在大多数语言中是非常不同的。人们可以很好地理解道具、状态和自顶向下的数据流，但仍然很难理解类。类不能很好地缩小，它们使得热重新加载不稳定且不可靠。
从概念上讲，React组件总是更接近函数。    

什么是钩子    
钩子是一种功能，它可以让你从功能组件“钩入”React状态和生命周期特性。    
什么是钩子?钩子是一种特殊的函数，可以让您“钩入”React特性。例如，useState是一个钩子，它允许您向功能组件添加反应状态。    
我什么时候用鱼钩?如果您编写了一个函数组件，并且意识到需要向其添加一些状态，那么以前您必须将其转换为一个类。现在您可以在现有的函数组件中使用一个钩子。    
React提供了一些内置的钩子，比如useState。您还可以创建自己的钩子来重用不同组件之间的有状态行为。    

State Hook    
React提供的一个名为useState的钩子。有时我们也称它为"状态挂钩"它允许我们添加本地状态来响应函数组件，你可以在单个组件中多次使用状态挂钩    

Effect Hook    
效果钩子让你在功能组件中执行副作用(或 “效果”)，在React组件中获取数据、设置订阅和手动更改DOM都是副作用的例子。调用useEffect时，您是在告诉React在刷新DOM的更改后运行“effect”函数。默认情况下，React会在每次渲染之后运行“effect”——包括第一次渲染。    
钩子允许您根据相关的部分(如添加和删除订阅)来组织组件中的副作用，而不是强制基于生命周期方法进行拆分，它允许您在组件中执行副作用，并且类似于类中的生命周期方法    
如果您熟悉React类生命周期方法，您可以将useEffect钩子看作是componentDidMount、componentDidUpdate和componentWillUnmount的组合。    
React组件有两种常见的副作用:不需要清理的副作用和需要清理的副作用。    
有时，我们希望在React更新了DOM之后运行一些额外的代码。网络请求、手工DOM突变和日志记录是不需要清理的常见效果示例。    
在React类组件中，render方法本身不应该造成副作用。因为这里还为时过早——我们通常希望在React更新了DOM之后再执行效果。这就是为什么在React类中，我们将副作用放到componentDidMount和componentDidUpdate中。请注意，我们必须在类中的这两个生命周期方法之间复制代码。    
这是因为在许多情况下，我们希望执行相同的副作用，而不管组件是刚刚挂载还是已经更新。从概念上讲，我们希望它在每次呈现之后发生——但是React类组件没有这样的方法。我们可以提取一个单独的方法，但是我们仍然必须在两个地方调用它。    
Effect Hook是做什么的?通过使用这个钩子，你告诉React你的组件需要在渲染之后做一些事情。React将记住您传递的函数(我们将把它称为“效果”)，并在执行DOM更新之后调用它。    
为什么在组件内部调用useEffect ?将useEffect放在组件中，我们可以直接从该效果访问状态变量(或任何prop)。我们不需要一个特殊的API来读取它——它已经在函数作用域中了。钩子包含了JavaScript闭包，并避免引入JavaScript已经提供解决方案的React-specific APIs。    
是否每次渲染后都会运行useEffect ?是的!默认情况下，它在第一次渲染和每次更新之后运行。    
与componentDidMount或componentDidUpdate不同，使用useEffect计划的效果不会阻止浏览器更新屏幕。这让你的应用程序感觉响应更快。大多数效果不需要同步发生。在不常见的情况下(比如测量布局)，有一个单独的useLayoutEffect钩子，其API与useEffect相同。    

钩子是JavaScript函数，但是它们附加了两个规则：    
只在顶层调用钩子。不要在循环、条件或嵌套函数内部调用钩子。    
只从React函数组件调用钩子。不要从常规JavaScript函数中调用钩子。    

建立自己的钩子    
有时，我们希望在组件之间重用一些有状态逻辑。传统上，这个问题有两种流行的解决方案:高阶组件和渲染道具。自定义钩子允许您这样做。钩子是重用有状态逻辑的一种方式，而不是状态本身。实际上，对钩子的每个调用都有一个完全隔离的状态——所以您甚至可以在一个组件中两次使用同一个自定义钩子。    
如果一个函数的名字以“use”开头，并且它调用了其他钩子，我们称它为自定义钩子。useSomething命名约定是我们的linter插件能够使用钩子发现代码中的bug的方式。    

还有一些不太常用的内置钩子，您可能会发现它们很有用。例如，useContext允许您订阅React上下文而不引入嵌套:    

useReducer可以通过一个reducer管理复杂组件的本地状态:    

钩子不能在类内部工作。但是您可以使用它们来代替编写类。    

调用useState是做什么的?它声明一个“状态变量”。 通常，当函数退出时，变量“消失”，但状态变量被React保留。    
我们传递给useState的参数是什么?useState()钩子的唯一参数是初始状态。与类不同，状态不必是一个对象。如果我们想在状态中存储两个不同的值，我们将调用两次useState()。    
useState返回什么?它返回两个值:当前状态和一个更新状态的函数。    

你可能想知道:为什么useState不命名为createState ?    
“Create”不是很准确，因为状态只在第一次渲染时创建。在接下来的渲染中，useState会给我们当前状态。    

读状态和更新状态在类组件和函数组件中的区别    

方括号是什么意思?    
当我们声明一个状态变量时，你可能已经注意到方括号: const [fruit, setFruit] = useState('banana');    
这种JavaScript语法称为“数组解构”。这意味着我们创建了两个新变量fruit和setFruit，其中fruit被设置为useState返回的第一个值，setFruit是第二个。    

function radioChangeHandler(event: React.ChangeEvent<HTMLInputElement>){    
    let value = (event.target as HTMLInputElement).value;    
    switch ((event.target as HTMLInputElement).name) {    
      case "IFRadio":    





